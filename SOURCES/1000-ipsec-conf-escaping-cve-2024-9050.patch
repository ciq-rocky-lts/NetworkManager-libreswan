From a427245a5619ca3baaa22cfda6acd4706cc5f6a5 Mon Sep 17 00:00:00 2001
From: Lubomir Rintel <lkundrak@v3.sk>
Date: Sun, 22 Sep 2024 14:20:22 +0200
Subject: [PATCH] all: rework formatting of ipsec.conf

Simplify the interface and validate each item carefully.

Note this fixes a security issue CVE-2024-9050, where insufficient
validation could lead to injection of potentialy malicious values
into the ipsec.conf snippet we send over to pluto.

https://issues.redhat.com/browse/RHEL-59565

[lkundrak@v3.sk: Backported from 1.24.0]

https://github.com/NetworkManager/NetworkManager-libreswan/commit/dcf8acfb25bd31e4b8cbd20c229da660238b5c1b

CVE-2024-9050
Orabug: 37206712
Signed-off-by: Kaylin Devchand <kaylin.devchand@oracle.com>
Reviewed-by: Alex Burmashev <alexander.burmashev@oracle.com>
---
 properties/nm-libreswan-editor-plugin.c |  29 +---
 shared/nm-utils/nm-macros-internal.h    |   8 +
 shared/nm-utils/nm-shared-utils.h       |   2 +
 shared/utils.c                          | 280 +++++++++++++++++++-------------
 shared/utils.h                          |  26 +--
 src/nm-libreswan-service.c              | 177 ++++++++++++--------
 6 files changed, 297 insertions(+), 225 deletions(-)

diff --git a/properties/nm-libreswan-editor-plugin.c b/properties/nm-libreswan-editor-plugin.c
index 8d3b3ff..27acfbb 100644
--- a/properties/nm-libreswan-editor-plugin.c
+++ b/properties/nm-libreswan-editor-plugin.c
@@ -139,38 +139,25 @@ export_to_file (NMVpnEditorPlugin *self,
 {
 	NMSettingVpn *s_vpn;
 	gboolean openswan = FALSE;
-	int fd, errsv;
 	gs_free_error GError *local = NULL;
-
-	fd = g_open (path, O_WRONLY | O_CREAT, 0666);
-	if (fd == -1) {
-		errsv = errno;
-		g_set_error (error, NMV_EDITOR_PLUGIN_ERROR, NMV_EDITOR_PLUGIN_ERROR_FAILED,
-		             _("Can't open file '%s': %s"), path, g_strerror (errsv));
-		return FALSE;
-	}
+	gs_free char *ipsec_conf = NULL;
 
 	s_vpn = nm_connection_get_setting_vpn (connection);
 	if (s_vpn)
 		openswan = nm_streq (nm_setting_vpn_get_service_type (s_vpn), NM_VPN_SERVICE_TYPE_OPENSWAN);
 
-	if (!nm_libreswan_config_write (fd,
-	                                connection,
-	                                nm_connection_get_id (connection),
-	                                NULL,
-	                                openswan,
-	                                TRUE,
-	                                NULL,
-	                                &local)) {
-		g_close (fd, NULL);
+	ipsec_conf = nm_libreswan_get_ipsec_conf (s_vpn,
+	                                          nm_connection_get_id (connection),
+	                                          NULL, openswan, TRUE, error);
+	if (ipsec_conf == NULL)
+		return FALSE;
+
+	if (!g_file_set_contents (path, ipsec_conf, -1, &local)) {
 		g_set_error (error, NMV_EDITOR_PLUGIN_ERROR, NMV_EDITOR_PLUGIN_ERROR_FAILED,
 		             _("Error writing to file '%s': %s"), path, local->message);
 		return FALSE;
 	}
 
-	if (!g_close (fd, error))
-		return FALSE;
-
 	return TRUE;
 }
 
diff --git a/shared/nm-utils/nm-macros-internal.h b/shared/nm-utils/nm-macros-internal.h
index 7a5c90f..d494516 100644
--- a/shared/nm-utils/nm-macros-internal.h
+++ b/shared/nm-utils/nm-macros-internal.h
@@ -42,6 +42,14 @@
 GS_DEFINE_CLEANUP_FUNCTION(void*, _nm_auto_free_impl, free)
 
 static inline void
+_nm_auto_free_gstring (GString **str)
+{
+	if (*str)
+		g_string_free (*str, TRUE);
+}
+#define nm_auto_free_gstring nm_auto(_nm_auto_free_gstring)
+
+static inline void
 _nm_auto_unset_gvalue_impl (GValue *v)
 {
 	g_value_unset (v);
diff --git a/shared/nm-utils/nm-shared-utils.h b/shared/nm-utils/nm-shared-utils.h
index cfa8f99..9565873 100644
--- a/shared/nm-utils/nm-shared-utils.h
+++ b/shared/nm-utils/nm-shared-utils.h
@@ -39,10 +39,12 @@ gint _nm_utils_ascii_str_to_bool (const char *str,
  *   error reason. Depending on the usage, this might indicate a bug because
  *   usually the target object should stay alive as long as there are pending
  *   operations.
+ * @NM_UTILS_ERROR_INVALID_ARGUMENT: invalid argument.
  */
 typedef enum {
 	NM_UTILS_ERROR_UNKNOWN = 0,                 /*< nick=Unknown >*/
 	NM_UTILS_ERROR_CANCELLED_DISPOSING,         /*< nick=CancelledDisposing >*/
+    NM_UTILS_ERROR_INVALID_ARGUMENT,            /*< nick=InvalidArgument >*/
 } NMUtilsError;
 
 #define NM_UTILS_ERROR (nm_utils_error_quark ())
diff --git a/shared/utils.c b/shared/utils.c
index f0bd85a..97a3bbc 100644
--- a/shared/utils.c
+++ b/shared/utils.c
@@ -24,150 +24,206 @@
 #include "nm-default.h"
 
 #include "utils.h"
+#include "nm-utils/nm-shared-utils.h"
 
 #include <unistd.h>
 #include <string.h>
 #include <errno.h>
 
-gboolean
-write_config_option_newline (int fd,
-                             gboolean new_line,
-                             NMDebugWriteFcn debug_write_fcn,
-                             GError **error,
-                             const char *format, ...)
+static gboolean
+printable_val (GString *str, const char *val, GError **error)
 {
-	gs_free char *string = NULL;
 	const char *p;
-	va_list args;
-	gsize l;
-	int errsv;
-	gssize w;
-
-	va_start (args, format);
-	string = g_strdup_vprintf (format, args);
-	va_end (args);
-
-	if (debug_write_fcn)
-		debug_write_fcn (string);
-
-	l = strlen (string);
-	if (new_line) {
-		gs_free char *s = string;
-
-		string = g_new (char, l + 1 + 1);
-		memcpy (string, s, l);
-		string[l] = '\n';
-		string[l + 1] = '\0';
-		l++;
-	}
 
-	p = string;
-	while (true) {
-		w = write (fd, p, l);
-		if (w == l)
-			return TRUE;
-		if (w > 0) {
-			g_assert (w < l);
-			p += w;
-			l -= w;
+	g_return_val_if_fail (val, FALSE);
+
+	for (p = val; *p != '\0'; p++) {
+		/* Printable characters except " and space allowed. */
+		if (*p != '"' && !g_ascii_isspace (*p) && g_ascii_isprint (*p))
 			continue;
-		}
-		if (w == 0) {
-			errsv = EIO;
-			break;
-		}
-		errsv = errno;
-		if (errsv == EINTR)
+		g_set_error (error, NM_UTILS_ERROR, NM_UTILS_ERROR_INVALID_ARGUMENT,
+			     _("Invalid character in '%s'"), val);
+		return FALSE;
+	}
+
+	g_string_append (str, val);
+	g_string_append_c (str, '\n');
+	return TRUE;
+}
+
+static gboolean
+string_val (GString *str, const char *val, GError **error)
+{
+	const char *p;
+
+	g_return_val_if_fail (val, FALSE);
+
+	for (p = val; *p != '\0'; p++) {
+		/* Printable characters except " allowed. */
+		if (*p != '"' && g_ascii_isprint (*p))
 			continue;
-		break;
+		g_set_error (error, NM_UTILS_ERROR, NM_UTILS_ERROR_INVALID_ARGUMENT,
+			     _("Invalid character in '%s'"), val);
+		return FALSE;
+	}
+
+	g_string_append_printf (str, "\"%s\"\n", val);
+	return TRUE;
+}
+
+static inline gboolean
+optional_string_val (GString *str, const char *key, const char *val, GError **error)
+{
+	if (val == NULL || val[0] == '\0')
+		return TRUE;
+	g_string_append_c (str, ' ');
+	g_string_append (str, key);
+	g_string_append_c (str, '=');
+
+	if (!string_val (str, val, error)) {
+		g_prefix_error (error, _("Invalid value for '%s': "), key);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+static inline gboolean
+optional_printable_val (GString *str, const char *key, const char *val, GError **error)
+{
+	if (val == NULL || val[0] == '\0')
+		return TRUE;
+
+	g_string_append_c (str, ' ');
+	g_string_append (str, key);
+	g_string_append_c (str, '=');
+
+	if (!printable_val (str, val, error)) {
+		g_prefix_error (error, _("Invalid value for '%s': "), key);
+		return FALSE;
 	}
-	g_set_error (error, NMV_EDITOR_PLUGIN_ERROR, NMV_EDITOR_PLUGIN_ERROR,
-	             _("Error writing config: %s"), g_strerror (errsv));
-	return FALSE;
+
+	return TRUE;
+}
+
+static inline gboolean
+optional_printable (GString *str, NMSettingVpn *s_vpn, const char *key, GError **error)
+{
+	return optional_printable_val (str,
+	                               key,
+	                               nm_setting_vpn_get_data_item (s_vpn, key),
+	                               error);
 }
 
-gboolean
-nm_libreswan_config_write (gint fd,
-                           NMConnection *connection,
-                           const char *con_name,
-                           const char *leftupdown_script,
-                           gboolean openswan,
-                           gboolean trailing_newline,
-                           NMDebugWriteFcn debug_write_fcn,
-                           GError **error)
+char *
+nm_libreswan_get_ipsec_conf (NMSettingVpn *s_vpn,
+                             const char *con_name,
+                             const char *leftupdown_script,
+                             gboolean openswan,
+                             gboolean trailing_newline,
+                             GError **error)
 {
-	NMSettingVpn *s_vpn;
-	const char *props_username;
-	const char *default_username;
+	nm_auto_free_gstring GString *ipsec_conf = NULL;
+	const char *username;
 	const char *phase1_alg_str;
 	const char *phase2_alg_str;
+	const char *right;
 	const char *leftid;
 
-	g_return_val_if_fail (fd > 0, FALSE);
-	g_return_val_if_fail (NM_IS_CONNECTION (connection), FALSE);
+	g_return_val_if_fail (NM_IS_SETTING_VPN (s_vpn), FALSE);
 	g_return_val_if_fail (!error || !*error, FALSE);
 	g_return_val_if_fail (con_name && *con_name, FALSE);
 
-	s_vpn = nm_connection_get_setting_vpn (connection);
-	g_return_val_if_fail (NM_IS_SETTING_VPN (s_vpn), FALSE);
+	ipsec_conf = g_string_sized_new (1024);
+	g_string_append (ipsec_conf, "conn ");
+	if (!printable_val (ipsec_conf, con_name, error)) {
+		g_prefix_error (error, _("Bad connection name: "));
+		return FALSE;
+	}
+
+	if (leftupdown_script) {
+		g_string_append (ipsec_conf, " auto=add\n");
+		g_string_append (ipsec_conf, " nm-configured=yes\n");
+		g_string_append (ipsec_conf, " leftupdown=");
+		if (!string_val (ipsec_conf, leftupdown_script, error))
+			g_return_val_if_reached (FALSE);
+	}
+
+	right = nm_setting_vpn_get_data_item (s_vpn, NM_LIBRESWAN_RIGHT);
+	if (right && right[0] != '\0') {
+		g_string_append (ipsec_conf, " right=");
+		if (!printable_val (ipsec_conf, right, error)) {
+			g_prefix_error (error, _("Invalid value for '%s': "),
+					NM_LIBRESWAN_RIGHT);
+			return FALSE;
+		}
+	} else {
+		g_set_error (error, NM_UTILS_ERROR, NM_UTILS_ERROR_INVALID_ARGUMENT,
+			     _("'%s' key needs to be present."), NM_LIBRESWAN_RIGHT);
+		return FALSE;
+	}
+
 
 	leftid = nm_setting_vpn_get_data_item (s_vpn, NM_LIBRESWAN_LEFTID);
 
-#define WRITE_CHECK_NEWLINE(fd, new_line, debug_write_fcn, error, ...) \
-	G_STMT_START { \
-		if (!write_config_option_newline ((fd), (new_line), debug_write_fcn, (error), __VA_ARGS__)) \
-			return FALSE; \
-	} G_STMT_END
-#define WRITE_CHECK(fd, debug_write_fcn, error, ...) WRITE_CHECK_NEWLINE (fd, TRUE, debug_write_fcn, error, __VA_ARGS__)
-
-	WRITE_CHECK (fd, debug_write_fcn, error, "conn %s", con_name);
-	if (leftid) {
-		WRITE_CHECK (fd, debug_write_fcn, error, " aggrmode=yes");
-		WRITE_CHECK (fd, debug_write_fcn, error, " leftid=@%s", leftid);
+	if (leftid && leftid[0] != '\0') {
+		g_string_append (ipsec_conf, " aggrmode=yes\n");
+		g_string_append (ipsec_conf, " leftid=@");
+		if (!printable_val (ipsec_conf, leftid, error)) {
+			g_prefix_error (error, _("Invalid value for '%s': "),
+			                NM_LIBRESWAN_LEFTID);
+			return FALSE;
+		}
 	}
-	WRITE_CHECK (fd, debug_write_fcn, error, " authby=secret");
-	WRITE_CHECK (fd, debug_write_fcn, error, " left=%%defaultroute");
-	WRITE_CHECK (fd, debug_write_fcn, error, " leftxauthclient=yes");
-	WRITE_CHECK (fd, debug_write_fcn, error, " leftmodecfgclient=yes");
-
-	if (leftupdown_script)
-		WRITE_CHECK (fd, debug_write_fcn, error, " leftupdown=%s", leftupdown_script);
-
-	default_username = nm_setting_vpn_get_user_name (s_vpn);
-	props_username = nm_setting_vpn_get_data_item (s_vpn, NM_LIBRESWAN_LEFTXAUTHUSER);
-	if (props_username && strlen (props_username))
-		WRITE_CHECK (fd, debug_write_fcn, error, " leftxauthusername=%s", props_username);
-	else if (default_username && strlen (default_username))
-		WRITE_CHECK (fd, debug_write_fcn, error, " leftxauthusername=%s", default_username);
-
-	WRITE_CHECK (fd, debug_write_fcn, error, " right=%s", nm_setting_vpn_get_data_item (s_vpn, NM_LIBRESWAN_RIGHT));
-	WRITE_CHECK (fd, debug_write_fcn, error, " remote_peer_type=cisco");
-	WRITE_CHECK (fd, debug_write_fcn, error, " rightxauthserver=yes");
-	WRITE_CHECK (fd, debug_write_fcn, error, " rightmodecfgserver=yes");
-	WRITE_CHECK (fd, debug_write_fcn, error, " modecfgpull=yes");
-	WRITE_CHECK (fd, debug_write_fcn, error, " rightsubnet=0.0.0.0/0");
+	g_string_append (ipsec_conf, " authby=secret\n");
+	g_string_append (ipsec_conf, " left=%%defaultroute\n");
+	g_string_append (ipsec_conf, " leftxauthclient=yes\n");
+	g_string_append (ipsec_conf, " leftmodecfgclient=yes\n");
+
+	username = nm_setting_vpn_get_data_item (s_vpn, NM_LIBRESWAN_LEFTXAUTHUSER);
+		if (username == NULL || username[0] == '\0')
+			username = nm_setting_vpn_get_user_name (s_vpn);
+		if (username != NULL && username[0] != '\0') {
+			g_string_append (ipsec_conf, " leftxauthusername=");
+			if (!string_val (ipsec_conf, username, error)) {
+				g_prefix_error (error, _("Invalid username: "));
+				return FALSE;
+			}
+		}
+
+	g_string_append (ipsec_conf, " remote_peer_type=cisco\n");
+	g_string_append (ipsec_conf, " rightxauthserver=yes\n");
+	g_string_append (ipsec_conf, " rightsubnet=0.0.0.0/0\n");
 
 	phase1_alg_str = nm_setting_vpn_get_data_item (s_vpn, NM_LIBRESWAN_IKE);
-	if (!phase1_alg_str || !strlen (phase1_alg_str))
-		WRITE_CHECK (fd, debug_write_fcn, error, " ike=aes-sha1");
-	else
-		WRITE_CHECK (fd, debug_write_fcn, error, " ike=%s", phase1_alg_str);
+	if (phase1_alg_str == NULL || phase1_alg_str[0] == '\0') {
+		phase1_alg_str = "aes-sha1";
+	}
+	if (!optional_string_val (ipsec_conf, NM_LIBRESWAN_IKE, phase1_alg_str, error))
+		return FALSE;
 
 	phase2_alg_str = nm_setting_vpn_get_data_item (s_vpn, NM_LIBRESWAN_ESP);
-	if (!phase2_alg_str || !strlen (phase2_alg_str))
-		WRITE_CHECK (fd, debug_write_fcn, error, " esp=aes-sha1;modp1024");
-	else
-		WRITE_CHECK (fd, debug_write_fcn, error, " esp=%s", phase2_alg_str);
+	if (phase2_alg_str == NULL || phase2_alg_str[0] == '\0') {
+		phase2_alg_str = "aes-sha1;modp1024";
+	}
+	if (!optional_string_val (ipsec_conf, NM_LIBRESWAN_ESP, phase2_alg_str, error))
+		return FALSE;
 
-	WRITE_CHECK (fd, debug_write_fcn, error, " rekey=yes");
-	WRITE_CHECK (fd, debug_write_fcn, error, " salifetime=24h");
-	WRITE_CHECK (fd, debug_write_fcn, error, " ikelifetime=24h");
-	WRITE_CHECK (fd, debug_write_fcn, error, " keyingtries=1");
+	g_string_append (ipsec_conf, " rekey=yes\n");
+	g_string_append (ipsec_conf, " salifetime=24h\n");
+	g_string_append (ipsec_conf, " ikelifetime=24h\n");
+	g_string_append (ipsec_conf, " keyingtries=1\n");
 
 	if (!openswan && g_strcmp0 (nm_setting_vpn_get_data_item (s_vpn, NM_LIBRESWAN_VENDOR), "Cisco") == 0)
-		WRITE_CHECK (fd, debug_write_fcn, error, " cisco-unity=yes");
+		g_string_append (ipsec_conf, " cisco-unity=yes\n");
 
-	WRITE_CHECK_NEWLINE (fd, trailing_newline, debug_write_fcn, error, " auto=add");
+	if (!optional_printable (ipsec_conf, s_vpn, NM_LIBRESWAN_DPDTIMEOUT, error))
+		return FALSE;
 
-	return TRUE;
+	g_string_append (ipsec_conf, " rightmodecfgserver=yes\n");
+	g_string_append (ipsec_conf, " modecfgpull=yes");
+	if (trailing_newline)
+		g_string_append_c (ipsec_conf, '\n');
+
+	return g_string_free (g_steal_pointer (&ipsec_conf), FALSE);
 }
diff --git a/shared/utils.h b/shared/utils.h
index eef444f..3a2fd69 100644
--- a/shared/utils.h
+++ b/shared/utils.h
@@ -24,25 +24,11 @@
 #ifndef __UTILS_H__
 #define __UTILS_H__
 
-typedef void (*NMDebugWriteFcn) (const char *setting);
-
-__attribute__((__format__ (__printf__, 5, 6)))
-gboolean write_config_option_newline (int fd,
-                                      gboolean new_line,
-                                      NMDebugWriteFcn debug_write_fcn,
-                                      GError **error,
-                                      const char *format, ...);
-
-#define write_config_option(fd, debug_write_fcn, error, ...) write_config_option_newline((fd), TRUE, debug_write_fcn, error, __VA_ARGS__)
-
-gboolean
-nm_libreswan_config_write (gint fd,
-                           NMConnection *connection,
-                           const char *con_name,
-                           const char *leftupdown_script,
-                           gboolean openswan,
-                           gboolean trailing_newline,
-                           NMDebugWriteFcn debug_write_fcn,
-                           GError **error);
+char *nm_libreswan_get_ipsec_conf (NMSettingVpn *s_vpn,
+                                   const char *con_name,
+                                   const char *leftupdown_script,
+                                   gboolean openswan,
+                                   gboolean trailing_newline,
+                                   GError **error);
 
 #endif /* __UTILS_H__ */
diff --git a/src/nm-libreswan-service.c b/src/nm-libreswan-service.c
index e3c91f5..b4443ab 100644
--- a/src/nm-libreswan-service.c
+++ b/src/nm-libreswan-service.c
@@ -103,6 +103,8 @@ typedef struct {
 	const char *whack_path;
 	char *secrets_path;
 
+	char *ipsec_conf;
+
 	gboolean openswan;
 	gboolean interactive;
 	gboolean pending_auth;
@@ -152,12 +154,6 @@ _LOGD_enabled (void)
 #define _LOGW(...) _NMLOG(LOG_WARNING, __VA_ARGS__)
 #define _LOGE(...) _NMLOG(LOG_EMERG, __VA_ARGS__)
 
-static void
-_debug_write_option (const char *setting)
-{
-	_LOGD ("Config %s", setting);
-}
-
 /****************************************************************/
 
 guint32
@@ -711,9 +707,9 @@ nm_libreswan_config_psk_write (NMSettingVpn *s_vpn,
                                GError **error)
 {
 	const char *pw_type, *psk, *leftid, *right;
-	int fd;
-	int errsv;
-	gboolean success;
+	gs_free const char *secrets = NULL;
+	mode_t old_mask;
+	gboolean res;
 
 	/* Check for ignored group password */
 	pw_type = nm_setting_vpn_get_data_item (s_vpn, NM_LIBRESWAN_PSK_INPUT_MODES);
@@ -723,48 +719,40 @@ nm_libreswan_config_psk_write (NMSettingVpn *s_vpn,
 	psk = nm_setting_vpn_get_secret (s_vpn, NM_LIBRESWAN_PSK_VALUE);
 	if (!psk)
 		return TRUE;
-
-	/* Write the PSK */
-	errno = 0;
-	fd = open (secrets_path, O_RDWR|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR);
-	if (fd < 0) {
-		errsv = errno;
-
-		if (errsv == ENOENT) {
-			gs_free char *dirname = g_path_get_dirname (secrets_path);
-
-			if (!g_file_test (dirname, G_FILE_TEST_IS_DIR)) {
-				g_set_error (error,
-				             NM_VPN_PLUGIN_ERROR,
-				             NM_VPN_PLUGIN_ERROR_LAUNCH_FAILED,
-				             "Failed to open secrets file: no directory %s",
-				             dirname);
-				return FALSE;
-			}
-		}
-
-		g_set_error (error,
-		             NM_VPN_PLUGIN_ERROR,
-		             NM_VPN_PLUGIN_ERROR_LAUNCH_FAILED,
-		             "Failed to open secrets file: (%d) %s.",
-		             errsv, g_strerror (errsv));
+	if (strchr (psk, '"') || strchr (psk, '\n')) {
+		g_set_error_literal (error,
+		                     NM_VPN_PLUGIN_ERROR,
+		                     NM_VPN_PLUGIN_ERROR_INVALID_CONNECTION,
+		                     _("Invalid character in password."));
 		return FALSE;
 	}
 
 	leftid = nm_setting_vpn_get_data_item (s_vpn, NM_LIBRESWAN_LEFTID);
 	if (leftid) {
-		success = write_config_option (fd, NULL, error, "@%s: PSK \"%s\"", leftid, psk);
+		if (strchr (leftid, '"') || strchr (leftid, '\n')) {
+			g_set_error_literal (error,
+			                     NM_VPN_PLUGIN_ERROR,
+			                     NM_VPN_PLUGIN_ERROR_INVALID_CONNECTION,
+			                     _("Invalid character in password."));
+			return FALSE;
+		}
+
+		secrets = g_strdup_printf ("@%s: PSK \"%s\"", leftid, psk);
 	} else {
 		right = nm_setting_vpn_get_data_item (s_vpn, NM_LIBRESWAN_RIGHT);
-		g_assert (right);
-		success = write_config_option (fd, NULL, error, "%s %%any: PSK \"%s\"", right, psk);
-	}
 
-	if (!success) {
-		g_close (fd, NULL);
-		return FALSE;
+		/* nm_libreswan_get_ipsec_conf() in _connect_common should've checked these. */
+		g_return_val_if_fail (right != NULL, FALSE);
+		g_return_val_if_fail (strchr (right, '"') == NULL, FALSE);
+		g_return_val_if_fail (strchr (right, '\n') == NULL, FALSE);
+
+		secrets = g_strdup_printf ("%s %%any: PSK \"%s\"", right, psk);
 	}
-	return g_close (fd, error);
+
+	old_mask = umask (S_IRWXG | S_IRWXO);
+	res = g_file_set_contents (secrets_path, secrets, -1, error);
+	umask (old_mask);
+	return res;
 }
 
 /****************************************************************/
@@ -1533,6 +1521,44 @@ done:
 }
 
 static gboolean
+write_config (int fd,
+              const char *string,
+              GError **error)
+{
+	const char *p;
+	gsize l;
+	int errsv;
+	gssize w;
+
+	_LOGD ("Config %s", string);
+
+	l = strlen (string);
+	p = string;
+	while (true) {
+		w = write (fd, p, l);
+		if (w == l)
+			return TRUE;
+		if (w > 0) {
+			g_assert (w < l);
+			p += w;
+			l -= w;
+			continue;
+		}
+		if (w == 0) {
+			errsv = EIO;
+			break;
+		}
+		errsv = errno;
+		if (errsv == EINTR)
+			continue;
+		break;
+	}
+	g_set_error (error, NMV_EDITOR_PLUGIN_ERROR, NMV_EDITOR_PLUGIN_ERROR,
+	             _("Error writing config: %s"), g_strerror (errsv));
+	return FALSE;
+}
+
+static gboolean
 connect_step (NMLibreswanPlugin *self, GError **error)
 {
 	NMLibreswanPluginPrivate *priv = NM_LIBRESWAN_PLUGIN_GET_PRIVATE (self);
@@ -1614,36 +1640,13 @@ connect_step (NMLibreswanPlugin *self, GError **error)
 		return TRUE;
 
 	case CONNECT_STEP_CONFIG_ADD: {
-		gboolean trailing_newline;
-		gs_free char *bus_name = NULL;
-		gs_free char *ifupdown_script = NULL;
 
 		if (!do_spawn (self, &priv->pid, &fd, NULL, error, priv->ipsec_path,
 		               "auto", "--replace", "--config", "-", uuid, NULL))
 			return FALSE;
 		priv->watch_id = g_child_watch_add (priv->pid, child_watch_cb, self);
-		g_object_get (self, NM_VPN_SERVICE_PLUGIN_DBUS_SERVICE_NAME, &bus_name, NULL);
 
-		/* openswan requires a terminating \n (otherwise it segfaults) while
-		 * libreswan fails parsing the configuration if you include the \n.
-		 * WTF?
-		 */
-		trailing_newline = priv->openswan;
-
-		ifupdown_script = g_strdup_printf ("\"%s %d %ld %s\"",
-		                                   NM_LIBRESWAN_HELPER_PATH,
-		                                   LOG_DEBUG,
-		                                   (long) getpid (),
-		                                   bus_name);
-
-		if (!nm_libreswan_config_write (fd,
-		                                priv->connection,
-		                                uuid,
-		                                ifupdown_script,
-		                                priv->openswan,
-		                                trailing_newline,
-		                                _debug_write_option,
-		                                error)) {
+		if (!write_config (fd, priv->ipsec_conf, error)) {
 			g_close (fd, NULL);
 			return FALSE;
 		}
@@ -1701,12 +1704,23 @@ _connect_common (NMVpnServicePlugin   *plugin,
 	NMLibreswanPluginPrivate *priv = NM_LIBRESWAN_PLUGIN_GET_PRIVATE (self);
 	NMSettingVpn *s_vpn;
 	const char *con_name = nm_connection_get_uuid (connection);
+	gs_free char *ipsec_banner = NULL;
+	gs_free char *ifupdown_script = NULL;
+	gs_free char *bus_name = NULL;
+	gboolean trailing_newline;
 
 	if (_LOGD_enabled ()) {
 		_LOGD ("connection:");
 		nm_connection_dump (connection);
 	}
 
+	if (priv->connect_step != CONNECT_STEP_FIRST) {
+		g_set_error_literal (error,
+			                 NM_VPN_PLUGIN_ERROR,
+			                 NM_VPN_PLUGIN_ERROR_LAUNCH_FAILED,
+			                 "Already connecting!");
+		return FALSE;
+	}
 	priv->ipsec_path = find_helper_bin ("ipsec", error);
 	if (!priv->ipsec_path)
 		return FALSE;
@@ -1730,13 +1744,30 @@ _connect_common (NMVpnServicePlugin   *plugin,
 	if (!nm_libreswan_secrets_validate (s_vpn, error))
 		return FALSE;
 
-	if (priv->connect_step != CONNECT_STEP_FIRST) {
-		g_set_error_literal (error,
-			                 NM_VPN_PLUGIN_ERROR,
-			                 NM_VPN_PLUGIN_ERROR_LAUNCH_FAILED,
-			                 "Already connecting!");
+	g_object_get (self, NM_VPN_SERVICE_PLUGIN_DBUS_SERVICE_NAME, &bus_name, NULL);
+
+	ifupdown_script = g_strdup_printf ("%s %d %ld %s",
+					   NM_LIBRESWAN_HELPER_PATH,
+					   LOG_DEBUG,
+					   (long) getpid (),
+					   bus_name);
+
+	/* openswan requires a terminating \n (otherwise it segfaults) while
+	 * libreswan fails parsing the configuration if you include the \n.
+	 * WTF?
+	 */
+	trailing_newline = priv->openswan;
+
+	/* Compose the ipsec.conf early, to catch configuration errors before
+	 * we initiate the conneciton. */
+	priv->ipsec_conf = nm_libreswan_get_ipsec_conf (s_vpn,
+		                                        con_name,
+		                                        ifupdown_script,
+		                                        priv->openswan,
+		                                        trailing_newline,
+		                                        error);
+	if (priv->ipsec_conf == NULL)
 		return FALSE;
-	}
 
 	priv->password = g_strdup (nm_setting_vpn_get_secret (s_vpn, NM_LIBRESWAN_XAUTH_PASSWORD));
 
@@ -1887,6 +1918,7 @@ real_disconnect (NMVpnServicePlugin *plugin, GError **error)
 		priv->watch_id = g_child_watch_add (priv->pid, child_watch_cb, plugin);
 
 	g_clear_object (&priv->connection);
+	g_clear_pointer (&priv->ipsec_conf, g_free);
 
 	return ret;
 }
@@ -1919,6 +1951,7 @@ finalize (GObject *object)
 {
 	NMLibreswanPluginPrivate *priv = NM_LIBRESWAN_PLUGIN_GET_PRIVATE (object);
 
+	g_clear_pointer (&priv->ipsec_conf, g_free);
 	delete_secrets_file (NM_LIBRESWAN_PLUGIN (object));
 	connect_cleanup (NM_LIBRESWAN_PLUGIN (object));
 	g_clear_object (&priv->connection);
-- 
1.8.3.1

